//File main.cpp
//Author: Jack Gillespie, Ulster University
//Date:29/01/2019
//Description: This lab demonstrates how to create an empty windows application using Win32.
//The basic steps required are:
//1.Define and register the windows class
//2.Create the windows object
//3.Handle event messages to and from the window

#include "stdafx.h"
#include <iostream>

//Global variables

//Handle to the window
HWND hwnd = NULL;

//name of the window(not the title)
LPCTSTR WindowName = "Lab1App";

//title of the window
LPCTSTR WindowTitle = "COM428 LAB 1";

//width and height of the window
int Width = 800;
int Height = 600;

//is window full screen
bool FullScreen = false;

//Forward Declarations

//create a window
bool InitializeWindow(HINSTANCE hInstance, int ShowWnd, int width, int height, bool fullscreen);

//main application loop
void MainLoop();

//callback function for windows messages
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

//Application entry point
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR lpCmdLine, int nShowCmd)
{
	//hInstance - the applications instance generated by windows
	//hPrevInstance - the applications previous instance(deprecated)
	//lpCmdLine- String containing application parameters
	//nShowCmd- value controlling the manner in which the application launches

	//create the window
	if (!InitializeWindow(hInstance, nShowCmd, Width, Height, FullScreen))
	{
		MessageBox(0, "Window Initialization - Failed",
			"Error", MB_OK);
		return 0;
	}

	//start the main loop
	MainLoop();

	return 0;
}//End WinMain


//create a window
bool InitializeWindow(HINSTANCE hInstance, int ShowWnd, int width, int height, bool fullscreen)
{
	//check to see if we want to go full screen
	if (fullscreen)
	{
		HMONITOR hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
		MONITORINFO mi = { sizeof(mi) };
		GetMonitorInfo(hmon, &mi);

		width = mi.rcMonitor.right - mi.rcMonitor.left;
		height = mi.rcMonitor.bottom - mi.rcMonitor.top;
	}

	//First we need to define a windows class information using WNDCLASSEX structure
	//Fill out the windows class structure
	WNDCLASSEX wc;

	wc.cbSize = sizeof(WNDCLASSEX); //the size of the structure
	wc.style = CS_HREDRAW | CS_VREDRAW; //specify the style of the window(CS_HREDRAW and CS_VREDRAW specify the window must be redrawn when resized horizontally or vertically
	wc.lpfnWndProc = WndProc; //specifies the callback function that will process event messages
	wc.cbClsExtra = NULL; //specifies the number of bytes to be allocated to store extra class information
	wc.cbWndExtra = NULL; //specifies the number of bytes to be allocated to store extra windows information
	wc.hInstance = hInstance; //a handle to the instance of the application
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION); //App icon
	wc.hCursor = LoadCursor(NULL, IDC_ARROW); //windows cursor
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 2); //colour value for the background colour of the window
	wc.lpszMenuName = NULL; // string specifying the resource name for the windowsm menu
	wc.lpszClassName = WindowName; // name of the windows class
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION); // small icon used by the class

	//Attempt to register the class
	if (!RegisterClassEx(&wc))
	{
		MessageBox(NULL, "Error registering class",
			"Error", MB_OK | MB_ICONERROR);
		return false;
	}

	//create the window with the class we registered
	hwnd = CreateWindowEx(NULL,
		WindowName, //name of the windows class(as above)
		WindowTitle, //windows caption
		WS_OVERLAPPEDWINDOW, //style of the window
		CW_USEDEFAULT, CW_USEDEFAULT, //X & Y coordinates window spawn location on screen
		width, height, //window width height
		NULL, //handle to the parent window
		NULL, //handle to the menu or child window
		hInstance, //handle to the application instance
		NULL); //Window creation data. Not required

	//if we didnt get a windows handle show ana error message
	if (!hwnd)
	{
		MessageBox(NULL, "Error creating window",
			"Error", MB_OK | MB_ICONERROR);
		return false;
	}

	//otherwise go full screen if 
	if (fullscreen)
	{
		SetWindowLong(hwnd, GWL_STYLE, 0);
	}

	//show the window
	ShowWindow(hwnd, ShowWnd);
	UpdateWindow(hwnd);

	return true;
}//End InitializeWindow

//Main Application Loop
void MainLoop() 
{
	MSG msg;
	ZeroMemory(&msg, sizeof(MSG));

	while (true)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			if (msg.message == WM_QUIT)
				break;

			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else
		{
			//run game code
		}
	}
}//End MainLoop

//callback function for windows messages
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	HBRUSH brush = CreateSolidBrush(RGB(0, 0, 255));
	static POINTS ptsBegin;
	//WndProc is the callback function used to process windows messages
	switch (msg)
	{
		

	case WM_KEYUP:
		if (wParam == 0x47)//G Key
		{
			/*MessageBox(0, "G Key Pressed",
				0, MB_OK | MB_ICONINFORMATION);
*/
			brush = CreateSolidBrush(RGB(0, 255, 0));
			SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)brush);
			InvalidateRect(hwnd, NULL, 1);
			UpdateWindow(hwnd);
			break;
		}

		if (wParam == 0x42)//B Key
		{
			/*MessageBox(0, "B Key Pressed",
			0, MB_OK | MB_ICONINFORMATION);
			*/
			brush = CreateSolidBrush(RGB(0, 0, 255));
			SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)brush);
			InvalidateRect(hwnd, NULL, 1);
			UpdateWindow(hwnd);
			break;
		}

		if (wParam == 0x52)//R Key
		{
			/*MessageBox(0, "R Key Pressed",
			0, MB_OK | MB_ICONINFORMATION);
			*/
			brush = CreateSolidBrush(RGB(255, 0, 0));
			SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)brush);
			InvalidateRect(hwnd, NULL, 1);
			UpdateWindow(hwnd);
			break;
		}
		return 0;

	case WM_KEYDOWN:
		if (wParam == VK_ESCAPE) 
		{
			if (MessageBox(0, "Are you sure you want to exit?",
				"Really?", MB_YESNO | MB_ICONQUESTION) == IDYES)
				DestroyWindow(hwnd);
		}
		return 0;

	case WM_LBUTTONDOWN:
		SetCapture(hwnd);
		ptsBegin = MAKEPOINTS(lParam);
		(MessageBox(0, "Left mouse button pressed", "Mouse?", MB_OK));
		//Output to the debug output window	
		OutputDebugString("test %d\n");

		return 0;

	case WM_RBUTTONDOWN:
		SetCapture(hwnd);
		ptsBegin = MAKEPOINTS(lParam);
		(MessageBox(0, "Right mouse button pressed", "Mouse?", MB_OK));
		//Output to the debug output window	
		OutputDebugString("test %d\n");

		return 0;

	case WM_MOUSEMOVE:
		
		brush = CreateSolidBrush(RGB(rand()%255+1, rand() % 255 + 1, rand() % 255 + 1));
		SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)brush);
		InvalidateRect(hwnd, NULL, 1);
		UpdateWindow(hwnd);
		return 0;

	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	}
	return DefWindowProc(hwnd,
		msg,
		wParam,
		lParam);
}



