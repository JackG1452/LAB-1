//File main.cpp
//Author: Jack Gillespie, Ulster University
//Date:29/01/2019
//Description: This lab demonstrates how to create an empty windows application using Win32.
//The basic steps required are:
//1.Define and register the windows class
//2.Create the windows object
//3.Handle event messages to and from the window

#include "stdafx.h"

//Global variables

//Handle to the window
HWND hwnd = NULL;

//name of the window(not the title)
LPCTSTR WindowName = "Lab1App";

//title of the window
LPCTSTR WindowTitle = "COM428 LAB 1";

//width and height of the window
int Width = 800;
int Height = 600;

//is window full screen
bool FullScreen = false;

//is Running
bool Running = true;

//Direct 3D 12 global variables
const int frameBufferCount = 2; //number of buffers we want, 2 for double buffering, 3 for triple buffering
ID3D12Device* device; //direct3d device
IDXGISwapChain3* swapChain; //swapchain used to switch between render targets
ID3D12CommandQueue* commandQueue; //container for command lists
ID3D12DescriptorHeap* rtvDescriptorHeap; // a descriptor heap to hold resources like the render targets
ID3D12Resource* renderTargets[frameBufferCount]; //number of render targetts equal to buffer count
ID3D12CommandAllocator* commandAllocator[frameBufferCount]; //we want enough allocators for each buffer * number of threads (we only have one thread)
ID3D12GraphicsCommandList* commandList; //command list we can record commands into, then execute them to render the frame
ID3D12Fence* fence[frameBufferCount]; // an object that is locked while our command list is being executed by the gpu. we need as many
									  //as we have allocators (more if we want to know when the gpu is finished with an asset)

HANDLE fenceEvent; //handle to an event when our fence is unlocked by the gpu
UINT64 fenceValue[frameBufferCount]; //this value is incremented each frame. each fence will have its own value
int frameIndex; //current rtv we are on
int rtvDescriptorSize; //size of the rtv descriptor on the device (all front and back buffers will be the same size)

//New globals for drawing
ID3D12PipelineState* pipelineStateObject; //PSO containing pipeline state
ID3D12RootSignature* rootSignature; //root signature defines data shaders will access
D3D12_VIEWPORT viewport; //area that output from rasterizer will be strecthed to
D3D12_RECT scissorRect; //area to draw in. pixels outside that area will not be drawn onto
ID3D12Resource* vertexBuffer; // default buffer in GPU memory that we will load vertex data for our triangle into
D3D12_VERTEX_BUFFER_VIEW vertexBufferView; //a structure containing a pointer to the vertex data in gpu memory
											//total size of the buffer, and size of each element(vertex)

//our vertex structure
struct Vertex {
	XMFLOAT3 pos;
};

//function declarations
bool InitD3D(); //initializes direct3d 12
void Update(); //update the game logic
void UpdatePipeline(); //update the direct3d pipeline (update command lists)
void Render(); //execute the command list
void Cleanup(); //release com objects and clean up memory
void WaitForPreviousFrame(); //wait until gpu is finished with command list

//Forward Declarations

//create a window
bool InitializeWindow(HINSTANCE hInstance, int ShowWnd, int width, int height, bool fullscreen);

//main application loop
void MainLoop();

//callback function for windows messages
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

//Application entry point
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR lpCmdLine, int nShowCmd)
{
	//hInstance - the applications instance generated by windows
	//hPrevInstance - the applications previous instance(deprecated)
	//lpCmdLine- String containing application parameters
	//nShowCmd- value controlling the manner in which the application launches

	//create the window
	if (!InitializeWindow(hInstance, nShowCmd, Width, Height, FullScreen))
	{
		MessageBox(0, "Window Initialization - Failed",
			"Error", MB_OK);
		return 0;
	}

	//initialize direct3d
	if (!InitD3D())
	{
		MessageBox(0, "Failed to initialize direct3d 12",
			"Error", MB_OK);
		Cleanup();
		return 1;
	}

	//start the main loop
	MainLoop();

	//we want to wait for gpu to finish executing the command list before we start releasing everything
	WaitForPreviousFrame();

	//close the fence event
	CloseHandle(fenceEvent);

	return 0;
}//End WinMain


//create a window
bool InitializeWindow(HINSTANCE hInstance, int ShowWnd, int width, int height, bool fullscreen)
{
	//check to see if we want to go full screen
	if (fullscreen)
	{
		HMONITOR hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
		MONITORINFO mi = { sizeof(mi) };
		GetMonitorInfo(hmon, &mi);

		width = mi.rcMonitor.right - mi.rcMonitor.left;
		height = mi.rcMonitor.bottom - mi.rcMonitor.top;
	}

	//First we need to define a windows class information using WNDCLASSEX structure
	//Fill out the windows class structure
	WNDCLASSEX wc;

	wc.cbSize = sizeof(WNDCLASSEX); //the size of the structure
	wc.style = CS_HREDRAW | CS_VREDRAW; //specify the style of the window(CS_HREDRAW and CS_VREDRAW specify the window must be redrawn when resized horizontally or vertically
	wc.lpfnWndProc = WndProc; //specifies the callback function that will process event messages
	wc.cbClsExtra = NULL; //specifies the number of bytes to be allocated to store extra class information
	wc.cbWndExtra = NULL; //specifies the number of bytes to be allocated to store extra windows information
	wc.hInstance = hInstance; //a handle to the instance of the application
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION); //App icon
	wc.hCursor = LoadCursor(NULL, IDC_ARROW); //windows cursor
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 2); //colour value for the background colour of the window
	wc.lpszMenuName = NULL; // string specifying the resource name for the windowsm menu
	wc.lpszClassName = WindowName; // name of the windows class
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION); // small icon used by the class

	//Attempt to register the class
	if (!RegisterClassEx(&wc))
	{
		MessageBox(NULL, "Error registering class",
			"Error", MB_OK | MB_ICONERROR);
		return false;
	}

	//create the window with the class we registered
	hwnd = CreateWindowEx(NULL,
		WindowName, //name of the windows class(as above)
		WindowTitle, //windows caption
		WS_OVERLAPPEDWINDOW, //style of the window
		CW_USEDEFAULT, CW_USEDEFAULT, //X & Y coordinates window spawn location on screen
		width, height, //window width height
		NULL, //handle to the parent window
		NULL, //handle to the menu or child window
		hInstance, //handle to the application instance
		NULL); //Window creation data. Not required

	//if we didnt get a windows handle show ana error message
	if (!hwnd)
	{
		MessageBox(NULL, "Error creating window",
			"Error", MB_OK | MB_ICONERROR);
		return false;
	}

	//otherwise go full screen if 
	if (fullscreen)
	{
		SetWindowLong(hwnd, GWL_STYLE, 0);
	}

	//show the window
	ShowWindow(hwnd, ShowWnd);
	UpdateWindow(hwnd);

	return true;
}//End InitializeWindow

//Main Application Loop
void MainLoop() 
{
	MSG msg;
	ZeroMemory(&msg, sizeof(MSG));

	while (true)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			if (msg.message == WM_QUIT)
				break;

			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else
		{
			//run game code
			Update(); //Update game logic
			Render(); //Execute the command queue
		}
	}
}//End MainLoop

//callback function for windows messages
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	HBRUSH brush = CreateSolidBrush(RGB(0, 0, 255));
	static POINTS ptsBegin;
	//WndProc is the callback function used to process windows messages
	switch (msg)
	{
		

	case WM_KEYUP:
		if (wParam == 0x47)//G Key
		{
			/*MessageBox(0, "G Key Pressed",
				0, MB_OK | MB_ICONINFORMATION);
*/
			brush = CreateSolidBrush(RGB(0, 255, 0));
			SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)brush);
			InvalidateRect(hwnd, NULL, 1);
			UpdateWindow(hwnd);
			break;
		}

		if (wParam == 0x42)//B Key
		{
			/*MessageBox(0, "B Key Pressed",
			0, MB_OK | MB_ICONINFORMATION);
			*/
			brush = CreateSolidBrush(RGB(0, 0, 255));
			SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)brush);
			InvalidateRect(hwnd, NULL, 1);
			UpdateWindow(hwnd);
			break;
		}

		if (wParam == 0x52)//R Key
		{
			/*MessageBox(0, "R Key Pressed",
			0, MB_OK | MB_ICONINFORMATION);
			*/
			brush = CreateSolidBrush(RGB(255, 0, 0));
			SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)brush);
			InvalidateRect(hwnd, NULL, 1);
			UpdateWindow(hwnd);
			break;
		}
		return 0;

	case WM_KEYDOWN:
		if (wParam == VK_ESCAPE) 
		{
			if (MessageBox(0, "Are you sure you want to exit?",
				"Really?", MB_YESNO | MB_ICONQUESTION) == IDYES)
				DestroyWindow(hwnd);
		}
		return 0;

	case WM_LBUTTONDOWN:
		SetCapture(hwnd);
		ptsBegin = MAKEPOINTS(lParam);
		(MessageBox(0, "Left mouse button pressed", "Mouse?", MB_OK));
		//Output to the debug output window	
		OutputDebugString("test %d\n");

		return 0;

	case WM_RBUTTONDOWN:
		SetCapture(hwnd);
		ptsBegin = MAKEPOINTS(lParam);
		(MessageBox(0, "Right mouse button pressed", "Mouse?", MB_OK));
		//Output to the debug output window	
		OutputDebugString("test %d\n");

		return 0;

	case WM_MOUSEMOVE:
		
		brush = CreateSolidBrush(RGB(rand()%255+1, rand() % 255 + 1, rand() % 255 + 1));
		SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)brush);
		InvalidateRect(hwnd, NULL, 1);
		UpdateWindow(hwnd);
		return 0;

	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	}
	return DefWindowProc(hwnd,
		msg,
		wParam,
		lParam);
}

bool InitD3D()
{
	//out Initialize D3D function does the following:
	//1.Create a D3D device which we used to access the GPU
	//2.Define and create our swap chain
	//3.Create the render target descriptor heap
	//4.Create our render target view
	//5.Create our depth/stencil buffer and view

	HRESULT hr;

	//Create the device
	//IDXGIFactory is an interface for creating DirectX Graphics Infrastructure (DXGI) objectss
	IDXGIFactory4* dxgiFactory;
	hr = CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory));
	if (FAILED(hr))
	{
		return false;
	}

	IDXGIAdapter1* adapter; //adapters are the graphics card (this includes the embedded graphics on the motherboard)
	int adapterIndex = 0; // we'll start looking for directx 12 compatible graphics devices starting at index 0
	bool adapterFound = false; //set this to true when a good one was found

	//find first hardware gpu that supports d3d 12
	while (dxgiFactory->EnumAdapters1(adapterIndex, &adapter) != DXGI_ERROR_NOT_FOUND)
	{
		DXGI_ADAPTER_DESC1 desc;
		adapter->GetDesc1(&desc);

		if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE)
		{
			//we dont want a software device
			adapterIndex++; //add this line here. Not currently in downloadable project
			continue;
		}
		//want a device that is compatible with direct3d 12 (feature level 11 or higher)
		hr = D3D12CreateDevice(adapter, D3D_FEATURE_LEVEL_11_0, __uuidof(ID3D12Device), nullptr);
		if (SUCCEEDED(hr))
		{
			adapterFound = true;
			break;
		}
		adapterIndex++;
	}
	if (!adapterFound)
	{
		return false;
	}

	//so if we got this far we have an adapter that supports feature level 11.0 (DX12) so lets create the device
	hr = D3D12CreateDevice(
		adapter, //adapter we want to create
		D3D_FEATURE_LEVEL_11_0, //min feautre level our app requires support for
		IID_PPV_ARGS(&device) // COM ID of the ID3D12Device interface we want to create
	);
	if (FAILED(hr))
	{
		return false;
	}

	//now we have a D3D12 device lets create the Command Queue for our device
	//we will use the command queue to execute command lists which contain commands for the gpu

	D3D12_COMMAND_QUEUE_DESC cqDesc = {}; //we will be using all the default values
	hr = device->CreateCommandQueue(&cqDesc, IID_PPV_ARGS(&commandQueue)); //create command queue
	if (FAILED(hr))
	{
		return false;
	}

	//create the swap chain (double/triple buffering)

	DXGI_MODE_DESC backBufferDesc = {}; //this is to describe our display mode
	backBufferDesc.Width = Width; //buffer width
	backBufferDesc.Height = Height; //buffer height
	backBufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; //format of buffer(rgba 32 bits 8 bits for each channel)

	//describe multi-sampling. we are not multi-sampling so we set the count to 1 (need at least one sample of course)
	DXGI_SAMPLE_DESC sampleDesc = {};
	sampleDesc.Count = 1; // multisample count (no multisampling we just put 1 since we still need 1 sample)

	DXGI_SWAP_CHAIN_DESC swapChainDesc = {};
	swapChainDesc.BufferDesc.Width = Width; //buffer width
	swapChainDesc.BufferDesc.Height = Height; //buffer height
	swapChainDesc.BufferDesc.RefreshRate.Numerator = 60; //refresh rates in Hz
	swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;
	swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; //format of buffer(rgba 32 bits 8 bits for each channel)
	swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED; //the method the raster uses to create an image on a surface
	swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED; //how an image is strecthed to fit a given monitors resolution
	swapChainDesc.SampleDesc.Count = 1; //number of multisamples
	swapChainDesc.SampleDesc.Quality = 0; // multisampling quality
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; //use resource as an output render target
	swapChainDesc.BufferCount = frameBufferCount; //2 for front and back buffer (double buffering)
	swapChainDesc.OutputWindow = hwnd; //handle to our window
	swapChainDesc.Windowed = !FullScreen; //set to true, then if in fullscreen must call SetFullScreenState with true for full screen to get uncapped fps
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD; //dxgi will dsicard the buffer (data) after we call present
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH; //allow switch between windows and fullscreen

	IDXGISwapChain* tempSwapChain;

	dxgiFactory->CreateSwapChain(
		commandQueue, //queue will be flushed once the swap chain is created
		&swapChainDesc, //give it the swap chain description we created above
		&tempSwapChain // store the created swap chain in a temp IDXGISwapChain interface
	);

	swapChain = static_cast<IDXGISwapChain3*>(tempSwapChain);

	frameIndex = swapChain->GetCurrentBackBufferIndex();

	//create the render target heap
	//we need a heap for each type of render targets
	//we have two types, render target views (RTVs) and depth stencil views (DSVs)

	//describe an RTV descriptor heap and create
	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
	rtvHeapDesc.NumDescriptors = frameBufferCount; //number of descriptors for this heap
	rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; //heap is a render target view heap

	//heap will not be directly referenced by the shaders (not shader visible), as this will store the output from the pipeline
	//othweise we would set the heaps flag to D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE
	rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	hr = device->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&rtvDescriptorHeap));
	if (FAILED(hr))
	{
		return false;
	}

	//get the size of a descriptor in this heap (this is a rtv heap, so only rtv descriptors should be stored in it
	//descriptor sizes may vary from device to device, which is why there is no set size and we must ask the
	//device to give us the ssize. we will use this size to increment a descriptor handle offset
	rtvDescriptorSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	//get a handle to the first descriptor in the descriptor heap a handle is basically a pointer,
	// but we cannot literally use it like a c++ pointer
	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvDescriptorHeap->GetCPUDescriptorHandleForHeapStart());

	//create a rtv for each buffer (double buffering is two buffers triple buffering is 3)
	for (int i = 0; i < frameBufferCount; i++)
	{
		//first we get the n'th buffer in the swap chain and store it in the n'th
		//position of our ID3D12Resource array
		hr = swapChain->GetBuffer(i, IID_PPV_ARGS(&renderTargets[i]));
		if (FAILED(hr))
		{
			return false;
		}
		//we create a render target view which binds the swap chain buffer (ID3D12Resource[n]) to the rtv handle
		device->CreateRenderTargetView(renderTargets[i], nullptr, rtvHandle);

		//we increment the rtv handle by the rtv descriptor we got above
		rtvHandle.Offset(1, rtvDescriptorSize);
	}

	//create the command allocators
	//command allocator is used to allocate memory on the gpu for the commands we want to execute
	//by calling execute on the command queue and providing a command list with the commands we want to execute
	//create the command allocators

	for (int i = 0; i < frameBufferCount; i++)
	{
		hr = device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator[i]));
		if (FAILED(hr)) 
		{
			return false;
		}
	}

	//create the command list
	//one command list for each thread. we are using 1 thread
	//create the command list with the first allocator
	hr = device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT,
		commandAllocator[0], NULL, IID_PPV_ARGS(&commandList));
	if (FAILED(hr))
	{
		return false;
	}

	//command lists are created in the recording state. our main loop will set it up for recording again so close it now
	commandList->Close();

	//create a fence and fence event
	// only using a single thread, so we only need one fence event
	//but since we are double buffering we have two fences one for each frame buffer

	//create fences
	for (int i = 0; i < frameBufferCount; i++)
	{
		hr = device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence[i]));
		if (FAILED(hr)) 
		{
			return false;
		}
		fenceValue[i] = 0; //set inital fence value to 0
	}

	//create a handle to a fence event
	fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
	if (fenceEvent == nullptr)
	{
		return false;
	}

	//create root signature
	CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
	rootSignatureDesc.Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	//serialize the root signature into bytecode
	ID3DBlob* signature;
	hr = D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &signature, nullptr);
	if (FAILED(hr))
	{
		return false;
	}
	//create the root signature by calling the createRootSignature() method of our device
	hr = device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	if (FAILED(hr))
	{
		return false;
	}

	//create vertex and pixel shaders




	return true;

}//End InitD3D

void Update()
{
	//update app logic such as moving camera of figuring out what objects are in view
}

void UpdatePipeline()
{
	HRESULT hr;

	/*this function is where we will add commands to the command list
	which include changing the state of the render target, setting the root signature and clearing
	the render target. later we will be setting vertex buffers and calling draw in this function*/

	//we have to wait for the gpu to finsih with the command allocator before we reset it
	WaitForPreviousFrame();

	//we can only reset ana allocator once the gpu is done with it
	//resetting an allocator frees the memory that the command list was stored in
	hr = commandAllocator[frameIndex]->Reset();
	if (FAILED(hr))
	{
		Running = false;
	}

	/*reset the command list by resetting the command list we are putting it into
	a recording state so we can start recording commands into the command allocator
	the command allocator that we reference here may have multiple command lists
	associated with it, but only one can be recording at any time. Make sure
	that any other command lists associated to this command allocator are in the closed state(not recording)
	Here you will pass an initial pipeline state object as the second parameter,
	but in this tutorial we are only clearing the rtv, and do not actually need anything
	but an initial default pipeline, which is what we get by setting 
	the second parameter to NULL*/
	hr = commandList->Reset(commandAllocator[frameIndex], NULL);
	if (FAILED(hr))
	{
		Running = false;
	}

	//here we start recording commands into the commandlist (which all commands will be stored in the commandallocator)

	//transition the frameIndex render target from the present state to the render target state so the commmand list draws to it starting from here
	commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex],
		D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

	//here we again get the handle to our current render target view so we can set it as the render target in the output merger stage of the pipeline
	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvDescriptorHeap->GetCPUDescriptorHandleForHeapStart(),
		frameIndex, rtvDescriptorSize);

	//set the render target for the output merger stage (the output of the pipeline)
	commandList->OMSetRenderTargets(1, &rtvHandle, FALSE, nullptr);

	//clear the render target by using the clearrendertargetview command
	const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
	commandList->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);

	//transition the frameIndex render target from the render target state to the present state. If the debug layer is enabled, you will recieve a
	//warning if present is called on the render target when its not in present state
	commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex],
		D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

	hr = commandList->Close();
	if (FAILED(hr))
	{
		Running = false;
	}
}

void Render()
{
	HRESULT hr;

	UpdatePipeline(); // update pipeline by sending commands to the commandqueue

	ID3D12CommandList* ppCommandLists[] = { commandList };

	//execute array of command lists
	commandQueue->ExecuteCommandLists(_countof(ppCommandLists), ppCommandLists);

	//this commmand goes in at the end of our command queue. we will know when our command queue
	//has finished because the fence value will be set to fencevalue from the gpu since the command
	//queue is being executed on the gpu
	hr = commandQueue->Signal(fence[frameIndex], fenceValue[frameIndex]);
	if (FAILED(hr))
	{
		Running = false;
	}

	//present the current backbuffer
	hr = swapChain->Present(0, 0);
	if (FAILED(hr))
	{
		Running = false;
	}
}

void Cleanup()
{
	//wait for the gpu to finish all frames
	for (int i = 0; i < frameBufferCount; ++i)
	{
		frameIndex = i;
		WaitForPreviousFrame();
	}

	//get swapchain out of fullscreen before exiting
	BOOL fs = false;
	if (swapChain->GetFullscreenState(&fs, NULL))
		swapChain->GetFullscreenState(false, NULL);

	device->Release();
	swapChain->Release();
	commandQueue->Release();
	rtvDescriptorHeap->Release();
	commandList->Release();

	for (int i = 0; i < frameBufferCount; ++i)
	{
		renderTargets[i]->Release();
		commandAllocator[i]->Release();
		fence[i]->Release();
	};
}//End CleanUp

void WaitForPreviousFrame()
{
	HRESULT hr;

	//swap current rtv buffer index so we draw on the correct buffer
	frameIndex = swapChain->GetCurrentBackBufferIndex();

	//if current fence value is still less than fenceValue then we know the gpu has not finished executing
	//the command queue since it haas not reached the commandQueue->Signla(fence, fenceValue) command
	if (fence[frameIndex]->GetCompletedValue() < fenceValue[frameIndex])
	{
		//we have the fence create an event which is signaled once the fences current value is fenceValue
		hr = fence[frameIndex]->SetEventOnCompletion(fenceValue[frameIndex], fenceEvent);
		if (FAILED(hr))
		{
			Running = false;
		}

		//we will wait until fence has triggered the event that its current value has reached fenceValue. once its value
		//has reached fenceValue we know the command queue has finished executing
		WaitForSingleObject(fenceEvent, INFINITE);
	}

	//increment fenceValue for next frame
	fenceValue[frameIndex]++;
}//End WaitForPreviousFrame

